def removeAt[T](n: Int, xs: List[T]): List[T] = xs match
    case Nil => Nil
    case y :: ys => if (n == 0) ys else y :: removeAt(n - 1, ys)

val xs = List('a', 'b', 'c', 'd')
removeAt(2, xs)


// Using the 'Any' data type here is advantageous because if 'flatten' takes an argument that is not a List,
// It would just return a List consisting of that single argument. 'flatten' takes any combinations of arguments
// and it will always return a single List.
def flatten(xs: Any): List[Any] = xs match
    case Nil => Nil
    case y :: ys => flatten(y) ++ flatten(ys)   // keep in mind that 'y' is itself an individual element of the list
    case _ => xs :: Nil    // anything other than a list, such as individual elements of the list 'xs' is 
                           // converted into a single element list

val ys = List(List(1, 1), 2, List(3, List(5, 8)))
flatten(ys)



// Exercise List method: splitAt
extension [T](xs: List[T])
    def splitAt(n: Int) = (xs.take(n), xs.drop(n))
val test = List(1, 2, 3, 4).splitAt(2)




// Difference between Partition and Span:
val nums = List(1, 2, 3, 4, 5, 6)
nums.partition(x => x % 2 != 0)
nums.span(x => x % 2 != 0)




// Exercise function: pack
def pack[T](xs: List[T]): List[List[T]] = xs match
  case Nil      => Nil
  case x :: xs1 => 
    val (more, rest) = xs1.span(y => y == x)
    (x :: more) :: pack(rest)

val elems = List("a", "a", "a", "b", "c", "c", "a")
pack(elems)





// Exercise function: encode
def encode[T](xs: List[T]): List[(T, Int)] = 
    pack(xs).map(x => (x.head, x.size))         // Remember that 'map' method also returns a List of elements 
                                                // generated by applying a function to every element of the 
                                                // argument List, which in this case is a List of sub-lists from 
                                                // the pack method

encode(elems)